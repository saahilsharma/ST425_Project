library(matrixcalc)
# Part II - Question 1 ##

# This function will will generate the pseudo-random numbers from a
# multi-variate normal distribution
# Parameters:
#   n = Number of variables to generate
#   p = Dimensionality
#   mu = Mean vector of random variables
#   sigma = Covariance matrix
mvrnorm = function(n, mu, sigma, use_choleksy = F) {
  p = length(mu)
  
  # Return error if dimensions don't line up
  if(p != ncol(sigma)) stop("The dimensions of sigma and mean vector aren't the same") 
  
  # Return an error if sigma is not positive definite
  if(!is.positive.definite(sigma)) stop("Sigma is not positive definite")
  
  # First, lets generate the standard normal r.v.s
  Z = matrix(rnorm(n*p), byrow = T, ncol = p)
  
  if(use_choleksy) 
  {
    # Use R's in built Cholesky function to decompose sigma
    # Full Explanation is given in the report
    sigma_decom = chol(sigma)
  } 
  else 
  {
    # Use eigen decomposition to simulate the multivariate normal dist
    # Explanation of this process is given in the Report
    eigens = eigen(sigma, symmetric = T)
    evals = eigens$values
    evectors = eigens$vectors
    D = sqrt(diag(evals))
    sigma_decom = evectors %*% D %*% t(evectors)
  }
  
  # Use the decomposed Sigma to generate the p-variate normal r.v.s
  X = mu + Z %*% sigma_decom
  
  return (X)
}

# This function produces a symmetric covariance matrix using the correlation
# provided where the covariance of the i-th and j-th element is computed
# by corr^(|j-i|)
# Parameters:
#   p = Dimensionality
#   var = Variance of every r.v. (we assume all r.v.s have the same variance)
#   corr = Base correlation
build_sigma = function(p, var, corr) {
  sigma = matrix(0L, nrow = p, ncol = p)
  for(i in 1:p) {
    for(j in i:p) {
      cov = var * corr^(abs(j-i))
      sigma[i,j] = cov
      sigma[j,i] = cov
    }
  }
  
  return (sigma)
}

# Helper function to allow us to run simulations across various different correlations
# Parameters:
#   n = Number of variables to generate
#   p = Dimensionality
#   var = Variance of every r.v. (we assume all r.v.s have the same variance)
#   correlations = List of correlations used to simulate different sigma's
#   use_cholesky = Boolean to specify whether we want to use cholesky decomp or eigen (default)
#   FUN = This is a function that accepts the index of the simulation and the dataframe of n p-variate
#         normal generated by mvrnorm (defined above). This allows the the caller to work with the output
#         of each simulation
run_simulation = function(n, p, mu, var, correlations, use_choleksy = F, FUN) {
  for(i in 1:length(correlations)) {
    sigma = build_sigma(p,var, correlations[i])
    X = mvrnorm(n, mu, sigma, use_choleksy = use_choleksy)
    XDF = as.data.frame(X)
    FUN(i,XDF)
  }
}

